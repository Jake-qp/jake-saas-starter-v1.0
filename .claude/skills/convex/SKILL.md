---
name: convex
description: Use when writing Convex backend functions, schema, queries, mutations, or actions. Before writing any Convex code.
---

# Convex Backend Development

## Overview

This project uses Convex with `convex-ents` (entity framework) and `convex-helpers` (custom function wrappers) to build a multi-tenant SaaS backend. Every Convex function flows through custom wrappers that inject entity-aware context, authentication, and typed helpers. If you skip the wrappers, nothing works.

## How Senior Convex Engineers Think

**"Where does context come from?"**
In this project, raw Convex context is never used directly. Custom wrappers in `convex/functions.ts` intercept every query and mutation, replacing `ctx.db` with `ctx.table` (the ents API) and injecting `viewer` / `viewerX()` for authentication. If you import from `_generated/server`, you bypass all of this and get a broken function that has no `table`, no `viewer`, and no type safety.

**"What's the authorization boundary?"**
Multi-tenant means every data access must be scoped to a team, and every mutation must verify the caller has permission on that team. Forgetting authorization is not a bug -- it is a security vulnerability. The permission check is not optional, even for "simple" mutations.

**"What does the ents API give me that raw db doesn't?"**
Edge traversal, soft deletion, scheduled deletion, unique field lookups, typed relationships, `insertMany`, search indexes, and pagination chaining. Using `ctx.db` directly means losing all of this and fighting the type system.

### What Separates Amateurs from Professionals

Amateurs write Convex functions that work for a single user. Professionals write functions that enforce tenant isolation, check permissions, handle soft-deleted records, and return minimal projections instead of leaking internal fields.

When catching yourself returning `await ctx.table("teams").getX(teamId)` without a permission check -- STOP. When returning raw ent objects instead of explicit field projections -- STOP.

## When to Use

- Writing any new Convex query, mutation, action, or internal function
- Adding or modifying the schema (`convex/schema.ts`)
- Adding new tables, edges, or indexes
- Writing permission checks or authorization logic
- Writing tests for Convex functions
- **NOT** for: Frontend React hooks, Next.js API routes, UI components

## Quick Reference

| Task | How |
|------|-----|
| Import query/mutation | `import { query, mutation } from "./functions"` (NEVER from `_generated/server`) |
| Import internal functions | `import { internalQuery, internalMutation } from "./functions"` |
| Get authenticated user | `ctx.viewerX()` (throws if not authed) or `ctx.viewer` (nullable) |
| Check permission (throws) | `await viewerHasPermissionX(ctx, teamId, "Permission Name")` |
| Check permission (boolean) | `await viewerHasPermission(ctx, teamId, "Permission Name")` |
| Get member with permission | `await viewerWithPermissionX(ctx, teamId, "Permission Name")` |
| Read by ID (throws) | `await ctx.table("tableName").getX(id)` |
| Read by unique field | `await ctx.table("tableName").get("fieldName", value)` (nullable) |
| Read by index | `await ctx.table("tableName", "indexName", (q) => q.eq("field", val)).unique()` |
| Traverse edge (single) | `await ent.edge("relatedTable")` |
| Traverse edge (collection) | `await ent.edge("relatedItems")` returns array |
| Check edge membership | `await ent.edge("role").edge("permissions").has(permId)` |
| Insert | `await ctx.table("tableName").insert({ ...fields })` returns ID |
| Insert and get entity | `await ctx.table("tableName").insert({ ...fields }).get()` |
| Insert many | `await ctx.table("tableName").insertMany([...])` |
| Update | `await ent.patch({ field: newValue })` |
| Delete | `await ent.delete()` (respects soft/scheduled deletion config) |
| Full-text search | `ctx.table("tableName").search("indexName", (q) => q.search("field", term).eq("filter", val))` |
| Paginate | `.paginate(paginationOpts)` with `paginationOptsValidator` in args |
| Map results | `.map(async (item) => ({ /* projection */ }))` |
| Filter | `.filter((q) => q.eq(q.field("deletionTime"), undefined))` |
| Throw user-facing error | `throw new ConvexError("message")` or `throw new ConvexError({ message, code })` |
| Schedule background work | `await ctx.scheduler.runAfter(0, internal.module.fn, { args })` |
| Get typed context types | `import { QueryCtx, MutationCtx } from "./types"` |
| Get typed entity | `import { Ent, EntWriter } from "./types"` |

## Architecture: File Layout

```
convex/
  _generated/          # Auto-generated by Convex CLI -- NEVER edit
    api.d.ts           # Type-safe function references (api.module.fn)
    dataModel.d.ts     # Table types, Id<"table">, Doc<"table">
    server.d.ts        # Base query/mutation/httpAction
  __tests__/           # Test files (Vitest + convex-test)
  functions.ts         # Custom wrappers -- ALL imports come from here
  schema.ts            # Ent schema (defineEntSchema, defineEnt)
  types.ts             # QueryCtx, MutationCtx, Ent<T>, EntWriter<T>
  permissions.ts       # Permission/role validators, checker functions
  utils.ts             # Pure helpers (slugify, emptyPage, normalize)
  init.ts              # Seed data (roles, permissions) -- internalMutation
  users.ts             # User creation/store
  invites.ts           # Invite CRUD
  users/
    teams.ts           # Team CRUD (list, create, delete)
    teams/
      members.ts       # Member CRUD (list, update, delete, viewerPermissions)
      messages.ts      # Message CRUD (list, create)
      roles.ts         # Role listing
```

Functions are organized by resource hierarchy. Team-scoped resources live under `users/teams/`. The `api` object mirrors this: `api.users.teams.messages.create`.

## Core Patterns

### 1. Custom Function Wrappers (THE Cardinal Rule)

Every function in this project MUST import from `convex/functions.ts`:

```typescript
// CORRECT -- always do this
import { query, mutation } from "./functions";
import { internalQuery, internalMutation } from "./functions";

// WRONG -- never do this
import { query, mutation } from "./_generated/server";
```

The wrappers in `functions.ts` do three things:
1. Replace `ctx.db` with `ctx.table` (the convex-ents API)
2. Look up the authenticated user from `ctx.auth.getUserIdentity()`
3. Inject `ctx.viewer` (nullable) and `ctx.viewerX()` (throws if not authed)

Without these wrappers, `ctx.table` does not exist, `ctx.viewer` does not exist, and every ents operation will fail at runtime.

### 2. Schema Definition with convex-ents

The schema uses `defineEntSchema` and `defineEnt` instead of Convex's raw `defineSchema`/`defineTable`:

```typescript
import { defineEnt, defineEntSchema, getEntDefinitions } from "convex-ents";
import { v } from "convex/values";

const schema = defineEntSchema({
  tableName: defineEnt({
    // Regular fields in constructor
    fieldA: v.string(),
    fieldB: v.optional(v.number()),
  })
    // Unique fields use .field()
    .field("slug", v.string(), { unique: true })
    // Single relationship (adds teamId column)
    .edge("team")
    // Collection back-reference (no column added here)
    .edges("members", { ref: true })
    // Compound index
    .index("byTeamAndUser", ["teamId", "userId"])
    // Full-text search
    .searchIndex("searchable", {
      searchField: "searchable",
      filterFields: ["teamId"],
    })
    // Deletion strategy
    .deletion("soft"),           // OR:
    .deletion("scheduled", { delayMs: 7 * 24 * 60 * 60 * 1000 }),
}, { schemaValidation: false });

export default schema;
export const entDefinitions = getEntDefinitions(schema);
```

Key rules:
- `.edge("table")` creates a foreign key field (`tableId`) -- use for belongs-to relationships
- `.edges("table", { ref: true })` declares a has-many back-reference -- no column created on this table
- `.field("name", validator, { unique: true })` enables lookup by unique field via `ctx.table("t").get("name", value)`
- `.deletion("soft")` adds a `deletionTime` field -- deleted records stay in the database
- `.deletion("scheduled", { delayMs })` marks for hard deletion after a delay
- Many-to-many: both sides use `.edges()` without `{ ref: true }` -- convex-ents creates a junction table

### 3. The Required Mutation Pattern

Every mutation that modifies team-scoped data MUST follow this order:

```typescript
export const updateSomething = mutation({
  args: {
    teamId: v.id("teams"),
    // ... other args
  },
  async handler(ctx, { teamId, ...args }) {
    // 1. AUTHENTICATE -- get the viewer (throws if not logged in)
    const viewer = ctx.viewerX();

    // 2. AUTHORIZE -- check team-level permission (throws if denied)
    await viewerHasPermissionX(ctx, teamId, "Manage Team");

    // 3. ENTITLE (when billing is active)
    // await checkEntitlement(ctx, teamId, "limitKey");

    // 4. RATE LIMIT (for expensive operations)
    // await checkRateLimit(ctx, key, limit);

    // 5. EXECUTE -- business logic
    const result = await ctx.table("things").insert({ ...args, teamId });

    // 6. AUDIT (for admin/sensitive actions)
    // await auditLog(ctx, { action: "thing.created", teamId, targetId: result });

    return result;
  },
});
```

For queries, the pattern is softer -- return null or empty results instead of throwing:

```typescript
export const listSomething = query({
  args: { teamId: v.id("teams") },
  async handler(ctx, { teamId }) {
    // Queries return null/empty for unauthorized, don't throw
    if (ctx.viewer === null || !(await viewerHasPermission(ctx, teamId, "Read Members"))) {
      return emptyPage(); // or return null
    }
    return await ctx.table("teams").getX(teamId).edge("things")
      .filter((q) => q.eq(q.field("deletionTime"), undefined))
      .paginate(paginationOpts)
      .map(async (thing) => ({
        _id: thing._id,
        name: thing.name,
        // Return ONLY the fields the client needs
      }));
  },
});
```

### 4. Permission System

Permissions are defined as a union type in `convex/permissions.ts`:

```typescript
export const vPermission = v.union(
  v.literal("Manage Team"),
  v.literal("Delete Team"),
  v.literal("Read Members"),
  v.literal("Manage Members"),
  v.literal("Contribute"),
);
export type Permission = Infer<typeof vPermission>;
```

Four checker functions, following the X-suffix convention:

| Function | Returns | On Failure |
|----------|---------|------------|
| `viewerWithPermission(ctx, teamId, name)` | `member` or `null` | Returns null |
| `viewerHasPermission(ctx, teamId, name)` | `boolean` | Returns false |
| `viewerWithPermissionX(ctx, teamId, name)` | `member` | Throws |
| `viewerHasPermissionX(ctx, teamId, name)` | `true` | Throws |

Use X-suffix variants in mutations (fail fast). Use non-X variants in queries (fail gracefully).

The permission check traverses: member -> role -> permissions edge to verify the caller has the named permission on the given team.

### 5. Ents Read Operations

```typescript
const team = await ctx.table("teams").getX(teamId);          // by ID, throws if missing
const user = await ctx.table("users").get("email", email);   // by unique field, nullable
const user = await ctx.table("users").getX("email", email);  // by unique field, throws
const member = await ctx.table("members", "teamUser", (q) => // by index, nullable
  q.eq("teamId", teamId).eq("userId", userId)).unique();
const member = await ctx.table("members", "teamUser", (q) => // by index, throws
  q.eq("teamId", teamId).eq("userId", userId)).uniqueX();
const anyRole = await ctx.table("roles").first();             // first record, nullable

// Edge traversal
const team = await member.edge("team");                       // single edge -> entity
const members = await ctx.table("teams").getX(teamId).edge("members"); // collection -> array
const permNames = await member.edge("role").edge("permissions").map((p) => p.name); // chained
const hasPerm = await member.edge("role").edge("permissions").has(permissionId);    // membership
```

### 6. Ents Write Operations

```typescript
const id = await ctx.table("messages").insert({ text, teamId, memberId: member._id }); // returns Id
const user = await ctx.table("users").insert({ ...fields }).get();       // insert + return entity
await ctx.table("permissions").insertMany([{ name: "Read" }, { name: "Write" }]); // bulk insert
await ctx.table("roles").insert({ name: "Admin", isDefault: false,
  permissions: [permId1, permId2] });                                    // M:M edge insert
await member.patch({ roleId: newRoleId });                               // partial update
await user.patch({ deletionTime: undefined });                           // un-soft-delete
await invite.delete();  // hard delete (no deletion strategy on table)
await member.delete();  // soft delete (.deletion("soft") on table)
await team.delete();    // scheduled delete (.deletion("scheduled") on table)
```

### 7. Pagination

Always use `paginationOptsValidator` in args and return the pagination result:

```typescript
import { paginationOptsValidator } from "convex/server";

export const list = query({
  args: {
    teamId: v.id("teams"),
    paginationOpts: paginationOptsValidator,
  },
  async handler(ctx, { teamId, paginationOpts }) {
    if (ctx.viewer === null || !(await viewerHasPermission(ctx, teamId, "Contribute"))) {
      return { page: [], isDone: true, continueCursor: "" };
    }
    return await ctx.table("teams").getX(teamId)
      .edge("messages")
      .order("desc")
      .paginate(paginationOpts)
      .map(async (msg) => {
        const member = await msg.edge("member");
        const user = await member.edge("user");
        return {
          _id: msg._id,
          _creationTime: msg._creationTime,
          text: msg.text,
          author: user.firstName ?? user.fullName,
          isAuthorDeleted: member.deletionTime !== undefined,
        };
      });
  },
});
```

For unauthorized access with pagination, use the `emptyPage()` helper from `convex/utils.ts` -- it returns a special `pageStatus: "SplitRequired"` that prevents `usePaginatedQuery` from hanging in a permanent loading state.

### 8. Search

Full-text search uses `.search()` which returns an ordered-by-relevance collection:

```typescript
const results = search === ""
  ? ctx.table("teams").getX(teamId).edge("members")
  : ctx.table("members").search("searchable", (q) =>
      q.search("searchable", normalizeStringForSearch(search))
        .eq("teamId", teamId)
    );

return await results
  .filter((q) => q.eq(q.field("deletionTime"), undefined))
  .paginate(paginationOpts)
  .map(async (member) => ({ /* projection */ }));
```

Always normalize search input with `normalizeStringForSearch()` from `convex/utils.ts` which strips diacritical marks.

### 9. Filtering Soft-Deleted Records

When querying tables with `.deletion("soft")`, always filter out deleted records:

```typescript
.filter((q) => q.eq(q.field("deletionTime"), undefined))
```

This applies to members, users, and any other soft-deleted table. Edge traversals through convex-ents handle this automatically in some cases, but explicit filtering is required when using `.paginate()` or `.filter()` chains.

### 10. Error Handling

```typescript
import { ConvexError } from "convex/values";

// User-facing errors (displayed in UI)
throw new ConvexError("There must be at least one admin left on the team");

// Structured errors
throw new ConvexError({ message: "Not found", code: 404 });

// Internal errors (logged, not shown to user)
throw new Error("Called api.users.store without valid auth token");
```

Use `ConvexError` for errors the client should see (validation failures, business rule violations). Use plain `Error` for unexpected states that indicate bugs.

### 11. Internal Functions and Scheduling

```typescript
import { internalMutation } from "./functions";

// Internal functions are not callable from the client
export const processWebhook = internalMutation({
  args: { data: v.any() },
  async handler(ctx, { data }) {
    // No auth check needed -- only callable from other server functions
    await ctx.table("events").insert({ ...data });
  },
});

// Schedule from a mutation or action
await ctx.scheduler.runAfter(0, internal.emails.send, { to, subject });
await ctx.scheduler.runAfter(60_000, internal.cleanup.run, { teamId });
```

Import `internal` from `convex/_generated/api` for type-safe internal function references.

### 12. Type System

```typescript
import { QueryCtx, MutationCtx, Ent, EntWriter } from "./types";
import { Id } from "./_generated/dataModel";

// Use for helper function signatures
async function checkAnotherAdminExists(ctx: QueryCtx, member: Ent<"members">) {
  const team = await ctx.table("teams").getX(member.teamId);
  // ...
}

// Use for mutation helper signatures
export async function createMember(
  ctx: MutationCtx,
  { teamId, roleId, user }: { teamId: Id<"teams">; roleId: Id<"roles">; user: Ent<"users"> }
) {
  return await ctx.table("members").insert({ teamId, userId: user._id, roleId, searchable: "..." });
}
```

`QueryCtx` has read-only `ctx.table`. `MutationCtx` has read-write `ctx.table`. Both have `viewer` and `viewerX()`. Use `Ent<"tableName">` for read-only entity types and `EntWriter<"tableName">` for writable entity types.

### 13. Validator Types

```typescript
import { v, Infer } from "convex/values";

v.string()  v.number()  v.boolean()  v.null()  v.any()     // primitives
v.optional(v.string())                                       // optional
v.array(v.string())                                          // arrays
v.object({ name: v.string(), age: v.number() })              // objects
v.id("teams")                                                // typed IDs

// Unions for enums (this project's pattern for permissions/roles)
const vStatus = v.union(v.literal("active"), v.literal("inactive"));
type Status = Infer<typeof vStatus>;
```

### 14. Testing with convex-test

```typescript
import { convexTest } from "convex-test";
import { describe, expect, it } from "vitest";
import schema from "../schema";

const modules = import.meta.glob("../**/*.ts");

describe("messages", () => {
  it("should create a message with valid permission", async () => {
    const t = convexTest(schema, modules);
    const asSarah = t.withIdentity({ name: "Sarah", tokenIdentifier: "user:sarah" });

    // Test with api references from _generated/api
    await asSarah.mutation(api.users.teams.messages.create, {
      teamId: someTeamId,
      text: "Hello",
    });
  });
});
```

Test files live in `convex/__tests__/`. Every new mutation MUST have permission and entitlement tests. Use `t.withIdentity()` to simulate authenticated users.

## Common Mistakes

| Wrong | Right | Why |
|-------|-------|-----|
| `import { query } from "./_generated/server"` | `import { query } from "./functions"` | Bypasses ents context, viewer injection, and type safety |
| `ctx.db.query("teams")` | `ctx.table("teams")` | `ctx.db` is explicitly set to `undefined` in the wrappers |
| Returning raw ent objects | `.map(async (item) => ({ _id: item._id, name: item.name }))` | Leaks internal fields (deletionTime, edge IDs, etc.) |
| No permission check in mutation | `await viewerHasPermissionX(ctx, teamId, "Manage Team")` | Security vulnerability: any authenticated user can modify any team |
| `throw new Error("Not allowed")` for user errors | `throw new ConvexError("Not allowed")` | Plain Error is logged but not displayed to client |
| Forgetting to filter soft-deleted records | `.filter((q) => q.eq(q.field("deletionTime"), undefined))` | Deleted records appear in query results |
| Using `ctx.viewer` without null check | `if (ctx.viewer === null) return null;` or use `ctx.viewerX()` | `ctx.viewer` is null for unauthenticated requests |
| Returning empty array for unauthorized paginated query | Use `emptyPage()` from `convex/utils` | Empty array causes `usePaginatedQuery` to hang in loading state |
| Putting helper functions in a query/mutation file without types | Type params as `ctx: QueryCtx` or `ctx: MutationCtx` from `./types` | Untyped helpers lose all ents type safety |
| Using `.getX(id)` without permission check first | Check permission THEN fetch the resource | Timing: authorize before you touch data |
| Adding new permission without updating `vPermission` union | Add literal to union in `permissions.ts` | Type system won't recognize the new permission string |

## Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| `convex` | ^1.13.2 | Core Convex runtime, validators, server utilities |
| `convex-ents` | ^0.9.5 | Entity framework: edges, soft deletion, typed relationships |
| `convex-helpers` | 0.1.27 | Custom function wrappers (`customQuery`, `customMutation`, `customCtx`) |
| `convex-test` | ^0.0.41 | Testing utilities for Vitest |

## Exit Criteria

Before considering any Convex function complete:

- [ ] Imports `query`/`mutation`/`internalQuery`/`internalMutation` from `./functions`, never from `_generated/server`
- [ ] Mutations follow the authenticate -> authorize -> entitle -> execute pattern
- [ ] Queries return null or empty results for unauthorized access (not throw)
- [ ] All team-scoped operations include a permission check
- [ ] Soft-deleted records are filtered out in queries
- [ ] Results are projected (explicit field selection), not raw ent objects
- [ ] Helper functions are typed with `QueryCtx`/`MutationCtx` and `Ent<"table">`
- [ ] User-facing errors use `ConvexError`, not plain `Error`
- [ ] Paginated queries use `paginationOptsValidator` and handle unauthorized with `emptyPage()`
- [ ] New permissions are added to the `vPermission` union in `permissions.ts`
- [ ] Tests exist for permission checks and business logic

**Done when:** The function handles authentication, authorization, soft deletion, and projections correctly -- and a code reviewer cannot find a path where an unauthorized user accesses another team's data.
